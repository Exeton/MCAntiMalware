package optic_fusion1.mcantimalware.check.checks;

import java.io.IOException;
import java.io.InputStream;
import java.util.Enumeration;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.zip.ZipEntry;
import java.util.zip.ZipFile;
import org.objectweb.asm.ClassReader;
import org.objectweb.asm.tree.AbstractInsnNode;
import org.objectweb.asm.tree.ClassNode;
import org.objectweb.asm.tree.LdcInsnNode;
import org.objectweb.asm.tree.MethodNode;
import optic_fusion1.mcantimalware.Main;
import optic_fusion1.mcantimalware.check.Check;
import optic_fusion1.mcantimalware.check.CheckType;
import optic_fusion1.mcantimalware.deobfuscator.StringDeobfuscator;
import xbrowniecodez.mcantimalware.checks.directleaks.DirectLeaksChecks;

public class DirectLeaks extends Check {

    public DirectLeaks(Main main) {
	super("LeakedPlugin", main, CheckType.PUP);
    }

    @Override
    public boolean process(String fileName, ZipFile zipFile) {
	Enumeration<? extends ZipEntry> entries = zipFile.entries();
	InputStream inputStream = null;
	while (entries.hasMoreElements()) {
	    try {
		ZipEntry current = entries.nextElement();
		inputStream = zipFile.getInputStream(current);
		if (current.getName().endsWith(".class")) {
		    try {
			ClassReader reader = new ClassReader(inputStream);
			ClassNode node = new ClassNode();
			reader.accept(node, 0);
			if (detect(node)) {
			    inputStream.close();
			    return true;
			}
		    } catch (Exception e) {
			continue;
		    }
		}
		inputStream.close();
	    } catch (IOException ex) {
		Logger.getLogger(Minator.class.getName()).log(Level.SEVERE, null, ex);
	    }
	}
	if (inputStream != null) {
	    try {
		inputStream.close();
	    } catch (IOException ex) {
		Logger.getLogger(SkySneak.class.getName()).log(Level.SEVERE, null, ex);
	    }
	}
	return false;
    }

    @Override
    public boolean detect(InputStream inputStream) {
	return false;
    }

    @Override
    public boolean detect(ClassNode classNode) {
	if (classNode.name.contains("de/xbrowniecodez/dlapi")) {
	    return true;
	}

	List<MethodNode> nodes = classNode.methods;
	for (MethodNode node : nodes) {
	    for (AbstractInsnNode insnNode : node.instructions.toArray()) {
		if (insnNode instanceof LdcInsnNode && ((LdcInsnNode) insnNode).cst instanceof String) {
		    String string = ((LdcInsnNode) insnNode).cst.toString();
		    boolean xorv1 = containsBlacklistedWord(StringDeobfuscator.XORV1(string));
		    boolean xorv2 = containsBlacklistedWord(StringDeobfuscator.XORV2(string));
		    boolean xorv3 = containsBlacklistedWord(StringDeobfuscator.XORV3(string));
		    boolean xorv4 = containsBlacklistedWord(StringDeobfuscator.decryptionArray(string));
		    boolean sig = DirectLeaksChecks.checkForDLSignature(classNode);
		    boolean bootstrap1 = DirectLeaksChecks.bootstrap1(classNode);
		    boolean bootstrap2 = DirectLeaksChecks.bootstrap2(classNode);
		    boolean host = false;
		    try {
			host = DirectLeaksChecks.doesDLHostCheckexist(classNode);
		    } catch (Throwable e1) {

		    }

		    if (xorv1 || xorv2 || xorv3 || xorv4 || host || sig || bootstrap1 || bootstrap2) {
			return true;
		    }
		}
	    }
	}
	return false;
    }

    public boolean containsBlacklistedWord(String string) {
	String[] blacklistedWords = new String[] { "#directleaks", "Please contact DirectLeaks. 0x2",
		"http://api.directleaks.net/api/directleaks", "[DirectLeaks] Error Code: 0x1", "Anti-Releak",
		"DirectLeaks", "vmi209890.contaboserver.net", "167.86.75.51", "#DirectLeaks Anti-Releak",
		"DirectLeaks-API", "de.xbrowniecodez.dlapi.Main", "de.xbrowniecodez.dlapi.HostsCheck" };
	for (String blacklistedWord : blacklistedWords) {
	    if (string.contains(blacklistedWord)) {
		return true;
	    }
	}
	return false;
    }

}
