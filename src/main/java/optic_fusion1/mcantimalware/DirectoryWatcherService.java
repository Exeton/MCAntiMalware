package optic_fusion1.mcantimalware;

import static java.nio.file.StandardWatchEventKinds.ENTRY_CREATE;
import static java.nio.file.StandardWatchEventKinds.ENTRY_DELETE;
import static java.nio.file.StandardWatchEventKinds.ENTRY_MODIFY;
import static java.nio.file.StandardWatchEventKinds.OVERFLOW;
import java.io.File;
import java.io.IOException;
import java.nio.file.FileSystems;
import java.nio.file.FileVisitResult;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.SimpleFileVisitor;
import java.nio.file.WatchEvent;
import java.nio.file.WatchKey;
import java.nio.file.WatchService;
import java.nio.file.attribute.BasicFileAttributes;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Map;
import java.util.Timer;
import java.util.TimerTask;

public class DirectoryWatcherService implements Runnable {

    @SuppressWarnings("unchecked")
    static <T> WatchEvent<T> cast(WatchEvent<?> event) {
	return (WatchEvent<T>) event;
    }

    /*
     * Wait this long after an event before processing the files.
     */
    private final int DELAY = 500;

    /*
     * Use a SET to prevent duplicates from being added when multiple events on the
     * same file arrive in quick succession.
     */
    HashSet<String> filesToReload = new HashSet<>();

    /*
     * Keep a map that will be used to resolve WatchKeys to the parent directory so
     * that we can resolve the full path to an event file.
     */
    private final Map<WatchKey, Path> keys;

    Timer processDelayTimer = null;

    private volatile Thread server;

    private boolean trace = false;

    private WatchService watcher = null;

    private Main main;

    public DirectoryWatcherService(Main main, Path dir, boolean recursive) throws IOException {
	this.main = main;
	this.watcher = FileSystems.getDefault().newWatchService();
	this.keys = new HashMap<>();

	if (recursive) {
	    registerAll(dir);
	} else {
	    register(dir);
	}

	// enable trace after initial registration
	this.trace = true;
    }

    private synchronized void addFileToProcess(String filename) {
	if (filename.contains("MCAntiMalware.jar") || filename.contains("malplugins.zip")) {
	    return;
	}
	if (!filename.endsWith(".jar") && !filename.endsWith(".zip") && !filename.endsWith(".rar")) {
	    return;
	}
	boolean alreadyAdded = filesToReload.add(filename) == false;
	main.getLogger().info("Queuing file for processing: " + filename + (alreadyAdded ? "(already queued)" : ""));
	if (processDelayTimer != null) {
	    processDelayTimer.cancel();
	}
	processDelayTimer = new Timer();
	processDelayTimer.schedule(new TimerTask() {

	    @Override
	    public void run() {
		processFiles();
	    }
	}, DELAY);
    }

    public synchronized void firstRun() {
	for (File file : new File(new File("plugins").getAbsolutePath()).listFiles()) {
	    if (file.getName().endsWith(".jar") || file.getName().endsWith(".zip") || file.getName().endsWith(".rar")) {
		if (!file.getName().contains("MCAntiMalware") && !file.getName().contains("malplugins.zip")) {
		    main.getCheckManager().process(file.getName(), file);
		}
	    }
	}
	if (main.shouldZipMaliciousPlugins() && main.foundMaliciousPlugins()) {
	    main.zipMaliciousPlugins();
	}
    }

    private synchronized void processFiles() {
	/*
	 * Iterate over the set of file to be processed
	 */
	for (Iterator<String> it = filesToReload.iterator(); it.hasNext();) {
	    String filename = it.next();
	    File file = new File(filename);
	    if (file.getName().endsWith(".jar") || file.getName().endsWith(".zip") || file.getName().endsWith(".rar")) {
		if (!file.exists()) {
		    it.remove();
		    continue;
		}
		if (!file.getName().contains("MCAntiMalware") && !file.getName().contains("malplugins.zip")) {
		    main.getLogger().info("Detected new file " + file.getName() + " checking if it's malicious");
		    main.getCheckManager().process(file.getName(), file);
		}
	    }
	    /*
	     * Remove this file from the set.
	     */
	    it.remove();
	}
	if (main.shouldZipMaliciousPlugins() && main.foundMaliciousPlugins()) {
	    main.zipMaliciousPlugins();
	}
    }

    /**
     * Register the given directory with the WatchService
     */
    private void register(Path dir) throws IOException {
	WatchKey key = dir.register(watcher, ENTRY_CREATE, ENTRY_DELETE, ENTRY_MODIFY);
	if (trace) {
	    Path prev = keys.get(key);
	    if (prev == null) {
		System.out.format("register: %s\n", dir);
	    } else {
		if (!dir.equals(prev)) {
		    System.out.format("update: %s -> %s\n", prev, dir);
		}
	    }
	}
	keys.put(key, dir);
    }

    /**
     * Register the given directory, and all its sub-directories, with the
     * WatchService.
     */
    private void registerAll(final Path start) throws IOException {
	// register directory and sub-directories
	Files.walkFileTree(start, new SimpleFileVisitor<Path>() {
	    @Override
	    public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException {
		if (dir.getFileName().toString().startsWith(".")) {
		    return FileVisitResult.SKIP_SUBTREE;
		}

		register(dir);
		return FileVisitResult.CONTINUE;
	    }
	});
    }

    @SuppressWarnings("unchecked")
    @Override
    public void run() {
	Thread thisThread = Thread.currentThread();
	while (server == thisThread) {
	    try {
		// wait for key to be signaled
		WatchKey key;
		try {
		    key = watcher.take();
		} catch (InterruptedException x) {
		    return;
		}

		Path dir = keys.get(key);
		if (dir == null) {
		    continue;
		}

		for (WatchEvent<?> event : key.pollEvents()) {
		    WatchEvent.Kind<?> kind = event.kind();
		    if (kind == OVERFLOW) {
			continue;
		    }

		    if (kind == ENTRY_MODIFY || kind == ENTRY_CREATE) {

			WatchEvent<Path> ev = (WatchEvent<Path>) event;
			Path name = ev.context();
			Path child = dir.resolve(name);

			String filename = child.toAbsolutePath().toString();

			addFileToProcess(filename);
		    }
		}

		key.reset();
	    } catch (Exception e) {
		e.printStackTrace();
	    }
	}
    }

    public void start() {
	server = new Thread(this);
	server.setName("Directory Watcher Service");
	server.start();
    }

    public void stop() {
	Thread moribund = server;
	server = null;
	if (moribund != null) {
	    moribund.interrupt();
	}
    }
}
